# Cryptography Guidelines
![Creative Commons License Icon](https://i.creativecommons.org/l/by-sa/4.0/88x31.png) This work is licensed under a [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/) because it took bloody ages to write.

## Background
This document outlines recommendations for cryptographic algorithm choices and parameters as well as important implementation details based on what I have learnt from reading about the subject and the consensus I have observed online. Note that *some* knowledge of cryptography is required to understand the terminology used in these guidelines.

My goal with these guidelines is to provide a resource that I wish I had access to when I first started writing programs related to cryptography. If this information helps prevent even just one vulnerability, then I consider it time well spent.

## Acknowledgements
These guidelines were inspired by [this](https://gist.github.com/atoponce/07d8d4c833873be2f68c34f9afc5a78a#file-gistfile1-md) Cryptographic Best Practices gist, Latacora's [Cryptographic Right Answers](https://latacora.singles/2018/04/03/cryptographic-right-answers.html), and [Crypto Gotchas](https://github.com/SalusaSecondus/CryptoGotchas), which is licensed under the [Creative Commons Attribution 4.0 International License](https://creativecommons.org/licenses/by/4.0/). The difference is that I mention newer algorithms and have tried to justify my algorithm recommendations whilst also offering important notes about using them correctly.

## Contribute
If you find these guidelines helpful, please **star** this repository and **share** the link around. Doing so might just prevent someone from making a catastrophic mistake.

If you have any **feedback**, please **contact me** privately [here](https://samuellucas.com/) or publicly [here](https://github.com/samuel-lucas6/Cryptography-Guidelines/discussions) to help improve these guidelines. [Pull requests](https://github.com/samuel-lucas6/Cryptography-Guidelines/pulls) are also welcome but please be prepared for things to be reworded.

## Disclaimer
I’m a psychology undergraduate with an interest in applied cryptography, not an experienced cryptographer. I primarily have experience with the [libsodium](https://doc.libsodium.org/) library since that’s what I’ve used for my projects, but I've also reported some security vulnerabilities related to cryptography.

Most experienced cryptographers don't have the time to write things like this, and the following information is freely available online or in books, so whilst more experience would be beneficial, I’m trying my best to provide accurate information that can be fact checked. **If I've made a mistake, please contact me to get it fixed**.

Note that the rankings are based on my opinion, algorithm availability in cryptographic libraries, and which algorithms are typically used in modern protocols, such as [TLS 1.3](https://www.davidwong.fr/tls13/), [Noise Protocol Framework](https://noiseprotocol.org/noise.html), [WireGuard](https://www.wireguard.com/protocol/), and so on. Such protocols and recommended practices make for the best guidelines because they’ve been approved by experienced professionals.

## General Guidance
1. Research, research, research: you often don’t need to know how cryptographic algorithms work under the hood to implement them correctly, just like how you don’t need to know how a car works to drive. However, you need to know enough about what you’re trying to do, which requires looking up relevant information online or in books, reading the documentation for the cryptographic library you’re using, reading RFC standards, reading helpful blog posts, and reading guidelines like this one. Furthermore, reading books about the subject in general will be beneficial, again like how knowing about cars can help if you break down. For a list of great resources, check out my [How to Learn About Cryptography](https://samuellucas.com/blog/how-to-learn-about-cryptography.html) blog post.

2. Check and check again: it’s your responsibility to get things right the first time around to the best of your ability rather than relying on peer review. Therefore, I **strongly** recommend always reading over security sensitive code at least twice and testing it to ensure that it’s operating as expected (e.g. checking the value of variables line by line using a debugger, using test vectors, etc).

3. Peer review is great but often doesn’t happen: unless your project is popular, you have a bug bounty program with cash rewards, or what you’re developing is for an organisation, very few people, perhaps none at all, will look through the code to find and report vulnerabilities. Similarly, receiving funding for a code audit will probably be near impossible.

4. **Please don't create your own custom cryptographic algorithms (e.g. a custom cipher or hash function)**: this is like flying a Boeing 747 without a pilot license but worse because even experienced cryptographers design [insecure](https://competitions.cr.yp.to/sha3.html) algorithms, which is why cryptographic algorithms are thoroughly analysed by a large number of cryptanalysts, usually as part of a [competition](https://competitions.cr.yp.to/index.html). By contrast, you rarely see experienced airline pilots crashing planes. The only *exception* to this rule is implementing something like Encrypt-then-MAC with secure, **existing** cryptographic algorithms **when you know what you're doing**.

5. **Please avoid coding existing cryptographic algorithms yourself (e.g. coding AES yourself)**: cryptographic libraries provide access to these algorithms for you to prevent people from making mistakes that cause vulnerabilities and to offer good performance. Whilst a select few algorithms are relatively simple to implement, like [HKDF](https://datatracker.ietf.org/doc/html/rfc5869), [many aren't](https://loup-vaillant.fr/articles/implementing-elligator) and require a great deal of experience to implement correctly. Lastly, another reason to avoid doing this is that it's really not fun since academic papers and reference implementations can be very difficult to understand.

## Cryptographic Libraries
#### Use (in order):
1. [Libsodium](https://doc.libsodium.org/): a modern, extremely fast, easy-to-use, well documented, and [audited](https://www.privateinternetaccess.com/blog/libsodium-v1-0-12-and-v1-0-13-security-assessment/) library that covers all common use cases, except for implementing TLS. However, it’s much bigger than Monocypher, meaning it’s harder to audit and not suitable for constrained environments, and requires the [Visual C++ Redistributable](https://support.microsoft.com/sl-si/topic/the-latest-supported-visual-c-downloads-2647da03-1eea-4433-9aff-95f26a218cc0) to work on Windows.

2. [Monocypher](https://monocypher.org/): another modern, easy-to-use, well documented, and [audited](https://monocypher.org/quality-assurance/audit) library, but it’s about [half](https://monocypher.org/speed) the speed of libsodium on desktops/servers, has no misuse resistant functions (e.g. like libsodium’s [secretstream()](https://doc.libsodium.org/secret-key_cryptography/secretstream) and [secretbox()](https://doc.libsodium.org/secret-key_cryptography/secretbox)), only supports Argon2i for password hashing, allowing for insecure parameters (please see the [Password Hashing/Password-Based Key Derivation](#password-hashingpassword-based-key-derivation) Notes section), and offers no memory locking, random number generation, or convenience functions (e.g. Base64/hex encoding, padding, etc). However, it’s compatible with libsodium whilst being much smaller, portable, and fast for constrained environments (e.g microcontrollers).

3. [Tink](https://developers.google.com/tink): a misuse resistant library that prevents common pitfalls, like nonce reuse. However, it doesn’t support hashing or password hashing, it’s not available in as many programming languages as libsodium and Monocypher, and it provides access to some algorithms that you shouldn’t use.

4. [LibHydrogen](https://libhydrogen.org): a lightweight, easy-to-use, hard-to-misuse, and well documented library suitable for constrained environments. The downsides are that it's not compatible with libsodium whilst also running [slower](https://monocypher.org/speed) than Monocypher. However, it has some advantages over Monocypher like support for random number generation, even on Arduino boards, and easy access to key exchange patterns, among other things.

#### Avoid (in order):
1. A random library (e.g. with 0 stars) on GitHub: assuming it’s not been written by an experienced professional and it’s not a libsodium or Monocypher [binding](https://github.com/ektrah/nsec) to another programming language, you should generally stay away from unpopular, unaudited libraries. They are much more likely to suffer from vulnerabilities and be significantly slower than the more popular, audited libraries. Also, note that even [experienced professionals make mistakes](https://github.com/agl/ed25519/issues/27).

2. [OpenSSL](https://www.openssl.org/): very difficult to use, let alone use correctly, offers access to algorithms that you shouldn't use, the documentation is a mess, and lots of [vulnerabilities](https://www.openssl.org/news/vulnerabilities.html) have been found over the years. These issues have led to OpenSSL [forks](https://www.libressl.org/index.html) and new, non-forked [libraries](https://bearssl.org/goals.html) that aim to be better alternatives if you need to implement TLS.

3. The library available in your [programming language](https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography?view=net-5.0): most languages provide access to old algorithms (e.g. MD5 and SHA1) that shouldn’t be used anymore instead of newer ones (e.g. BLAKE2, BLAKE3, and SHA3), which can lead to poor algorithm choices. Furthermore, the APIs are typically easy to misuse, the documentation may fail to mention important security related information, and the implementations will be slower than libsodium.

4. Other popular libraries I haven’t mentioned (e.g. [BouncyCastle](https://bouncycastle.org/), [CryptoJS](https://cryptojs.gitbook.io/docs/), etc): these again often provide or rely on dated algorithms and typically have bad documentation. For instance, CryptoJS uses an [insecure](https://www.npmjs.com/package/evp_bytestokey) KDF called [EVP_BytesToKey()](https://www.openssl.org/docs/man1.1.1/man3/EVP_BytesToKey.html) in OpenSSL when you pass a string password to [AES.encrypt()](https://cryptojs.gitbook.io/docs/#ciphers), and BouncyCastle has no C# documentation. However, this recommendation is too broad really since there are *some* libraries that I haven't mentioned that are worth using, like [PASETO](https://github.com/paragonie/paseto). Therefore, as a rule of thumb, **if it doesn't include several of the algorithms I recommend in this document, then it's probably bad**. Just do your research and assess the quality of the documentation.

5. [NaCl](https://nacl.cr.yp.to/): an unmaintained, less modern, and more confusing version of libsodium and Monocypher. For example, [crypto_sign()](https://nacl.cr.yp.to/sign.html) for digital signatures has been [experimental](https://nacl.cr.yp.to/sign.html) for several years. It also doesn’t have password hashing support and is supposedly [difficult to install/package](https://monocypher.org/why).

6. [TweetNaCl](https://tweetnacl.cr.yp.to/): unmaintained, [slower](https://monocypher.org/speed) than Monocypher, doesn’t offer access to newer algorithms, doesn’t have password hashing, and [doesn’t zero out buffers](https://monocypher.org/why).

#### Notes:
1. If the library you’re currently using/planning to use doesn’t support several of the algorithms I’m recommending, then it’s time to upgrade and take advantage of the improved security and performance benefits available to you if you switch.

2. Please read the documentation: don’t immediately jump into coding something because that’s how mistakes are made. Good libraries have high quality documentation that will explain potential security pitfalls and how to avoid them.

3. Some libraries release unauthenticated plaintext when using AEADs: for example, OpenSSL and BouncyCastle [apparently do](https://github.com/SalusaSecondus/CryptoGotchas). Firstly, don’t use these libraries for this reason and the reasons I’ve already listed. Secondly, **never do anything with unauthenticated plaintext; ignore it to be safe**.

4. Older does not mean better: you can argue that older algorithms are more battle tested and therefore proven to be a safe choice, but the reality is that most modern algorithms, like ChaCha20, BLAKE2, and Argon2, have been properly analysed at this point and shown to offer security and performance benefits over their older counterparts. Therefore, it doesn’t make sense to stick to this overly cautious mindset of avoiding newer algorithms, except for algorithms that are still candidates in a [competition](https://csrc.nist.gov/projects/post-quantum-cryptography) (e.g. new post-quantum algorithms), which do need further analysis to be considered safe.

5. You should prioritise speed: this can make a noticeable difference for the user. For example, a C# Argon2 library is going to be significantly slower than Argon2 in libsodium, meaning unnecessary and unwanted extra delay during key derivation. Libsodium is the go-to for speed on desktops/servers, and Monocypher is the go-to for constrained environments (e.g. microcontrollers).

## Symmetric Encryption
#### Use (in order):
1. [XChaCha20](https://doc.libsodium.org/advanced/stream_ciphers/xchacha20)-then-[BLAKE2b](https://www.blake2.net/) (Encrypt-then-MAC): **if you know what you are doing**, then implementing Encrypt-then-MAC offers better security than an AEAD because it provides better security properties, such as [key commitment](https://eprint.iacr.org/2020/1491.pdf), and allows for a longer authentication tag, making it more suitable for long-term storage. This combo is now being employed by [PASETO](https://github.com/paragonie/paseto/pull/127), an alternative to [JWT](https://jwt.io/), as well as my file encryption software called [Kryptor](https://www.kryptor.co.uk/). ChaCha20 has a [higher security margin](https://eprint.iacr.org/2019/1492.pdf) than AES whilst also being fast in software and [constant time](https://cr.yp.to/chacha/chacha-20080128.pdf), meaning it’s not vulnerable to timing attacks like AES [can be](https://cr.yp.to/antiforgery/cachetiming-20050414.pdf). Moreover, [Salsa20](https://cr.yp.to/snuffle/salsafamily-20071225.pdf), the cipher ChaCha20 was based on, underwent rigorous analysis as part of the [eSTREAM competition](https://www.ecrypt.eu.org/stream/e2-salsa20.html), and both ChaCha20 and Salsa20 have also received [further analysis](https://en.wikipedia.org/wiki/Salsa20#Cryptanalysis_of_Salsa20) since then.

2. [XChaCha20-Poly1305](https://doc.libsodium.org/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction): this is the gold standard for when you don’t know how to implement Encrypt-then-MAC or need maximum performance on all devices. As mentioned above, ChaCha20 has a higher security margin than AES, always runs in constant time, and (X)ChaCha20-Poly1305 is faster than AES-GCM without AES-NI hardware support. Note that XChaCha20-Poly1305 should be favoured over regular ChaCha20-Poly1305 in many cases because it allows for random nonces, which helps prevent nonce reuse (please see point 1 of the Notes section). If you just need a counter nonce or intend to use a unique key for encryption each time, then ChaCha20-Poly1305 is fine. Unfortunately, there are two ChaCha20-Poly1305 constructions - the original [ChaCha20-Poly1305](https://doc.libsodium.org/secret-key_cryptography/aead/chacha20-poly1305/original_chacha20-poly1305_construction) and [ChaCha20-Poly1305-IETF](https://datatracker.ietf.org/doc/html/rfc7539). The original construction is better because it has a smaller nonce, meaning it doesn’t encourage unsafe random nonces, and a larger internal counter, meaning it can encrypt more data using the same key and nonce pair (please see point 5 of the Notes section), but the IETF variant is more popular and should therefore generally be used.

3. [AES-CTR](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_(CTR)) (or [CBC](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_block_chaining_(CBC)))-then-[HMAC](https://datatracker.ietf.org/doc/html/rfc2104) (Encrypt-then-MAC): again, **if you know what you are doing**, this is superior to using an AEAD in terms of security for the reasons outlined in point 1 above. **AES-CTR should be preferred** because AES-CBC is less efficient, requires padding, and doesn't support a counter nonce. However, both AES-CTR-then-HMAC and AES-CBC-then-HMAC can be faster than AES-GCM without AES-NI hardware support. With that said, generating an IV for CBC and CTR can be a source of trouble, with CBC requiring unpredictable (aka random) IVs and CTR implementations differing in terms of nonce size and whether a random/counter nonce is safe.

4. [AES-GCM](https://en.wikipedia.org/wiki/Galois/Counter_Mode): the industry standard despite it not being the best and receiving some criticism. It’s easier to use correctly than Encrypt-then-MAC and faster than (X)ChaCha20-BLAKE2b, (X)ChaCha20-Poly1305, and AES-CTR-then-HMAC/AES-CBC-then-HMAC with AES-NI hardware support, but it has a weird nonce size (96-bits) that means you should use a counter nonce, [some](https://pycryptodome.readthedocs.io/en/latest/src/cipher/modern.html#gcm-mode) implementations incorrectly allow 128-bit nonces (**only use a 96-bit nonce** since longer nonces get [hashed](https://soatok.blog/2020/05/13/why-aes-gcm-sucks/), which could result in multiple nonces producing some of the same AES-CTR output), reusing a nonce is more [catastrophic](https://eprint.iacr.org/2016/475.pdf) than in AES-CBC for example, and there are [relatively small](https://doc.libsodium.org/secret-key_cryptography/aead#limitations) max encryption limits (e.g. ~350 GiB for a single key when using 16 KiB long messages). Furthermore, there can be [side-channels](https://eprint.iacr.org/2009/129.pdf) in software implementations and mitigating them [reduces the speed](https://doc.libsodium.org/secret-key_cryptography/aead#aes-256-gcm) of the algorithm. Therefore, AES-GCM should only be used when there’s hardware support, although I strongly recommend the above algorithms instead regardless.

#### Avoid (not in order because they’re all bad):
1. Your own [custom](https://github.com/Serpent27/PARSEC) symmetric encryption algorithm: even experienced cryptographers design [insecure](https://competitions.cr.yp.to/sha3.html) algorithms, which is why cryptographic algorithms are thoroughly analysed by a large number of cryptanalysts, usually as part of a [competition](https://competitions.cr.yp.to/index.html).

2. [AES-ECB](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_(ECB)): identical plaintext blocks get encrypted into identical ciphertext blocks, which means the algorithm lacks diffusion and fails to hide data patterns. In other words, it’s **horribly insecure**.

3. [RC4](https://en.wikipedia.org/wiki/RC4): there are lots of [attacks](https://en.wikipedia.org/wiki/RC4#Security) against it, rendering it **horribly insecure**.

4. [AES-CBC](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#CBC), [AES-CTR](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_(CTR)), [ChaCha20](https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant), and other **unauthenticated ciphers without a MAC**: this allows an attacker to tamper with the ciphertext without detection and can sometimes allow for other attacks, like [padding oracle attacks](https://en.wikipedia.org/wiki/Padding_oracle_attack) in the case of AES-CBC.

5. [Blowfish](https://en.wikipedia.org/wiki/Blowfish_(cipher)), [CAST-128](https://en.wikipedia.org/wiki/CAST-128), [GOST](https://en.wikipedia.org/wiki/GOST_(block_cipher)), [IDEA](https://en.wikipedia.org/wiki/International_Data_Encryption_Algorithm), [3DES](https://en.wikipedia.org/wiki/Triple_DES), [DES](https://en.wikipedia.org/wiki/Data_Encryption_Standard), [RC2](https://en.wikipedia.org/wiki/RC2), and **any cipher with a 64-bit block size**: a 64-bit block size means [collision attacks](https://sweet32.info/) can occur after encrypting a certain amount of data using the same key. **Don’t use any algorithm with a block size less than 128-bits**. Algorithms like DES and 3DES are also very old and have small key sizes that are **insecure**.

6. [One-time pad](https://en.wikipedia.org/wiki/One-time_pad): completely impractical since the key needs to be the same size as the message, and a **true** random number generator (e.g. atmospheric noise) is required to generate the keystream for it to be impossible to decrypt. Furthermore, some people think an [XOR cipher](https://en.wikipedia.org/wiki/XOR_cipher) with a repeating key is equivalent to a one-time pad, which is completely false. Repeating the key is [**horribly insecure**](https://en.wikipedia.org/wiki/XOR_cipher#Use_and_security). **Never do this**.

7. [AES-CCM](https://en.wikipedia.org/wiki/CCM_mode), [AES-EAX](https://en.wikipedia.org/wiki/EAX_mode), [AES-CFB](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_feedback_(CFB)), [AES-OFB](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Output_feedback_(OFB)), [AES-OCB](https://en.wikipedia.org/wiki/OCB_mode), [Serpent](https://en.wikipedia.org/wiki/Serpent_(cipher)), [Threefish](https://en.wikipedia.org/wiki/Threefish), [Twofish](https://en.wikipedia.org/wiki/Twofish), [Camellia](https://en.wikipedia.org/wiki/Camellia_(cipher)), [RC6](https://en.wikipedia.org/wiki/RC6), [ARIA](https://en.wikipedia.org/wiki/ARIA_(cipher)), [SEED](https://en.wikipedia.org/wiki/SEED), and other ciphers nobody uses: very few people use these because they’re worse in one way or another, except for AES-OCB, which has very good performance but is almost never used because it was patented until recently. For example, AES-CCM uses MAC-then-Encrypt and CBC-MAC, AES-EAX is slower than AES-GCM and uses OMAC, some of them are unbalanced in terms of security to performance (e.g. Serpent is slow whilst having a high security margin), some have received limited cryptanalysis, and implementations of uncommon non-AES algorithms are very rare in mainstream cryptographic libraries, with random implementations found on GitHub being less likely to be secure because these types of algorithms can be hard to implement correctly.

8. [AES-XTS](https://en.wikipedia.org/wiki/Disk_encryption_theory#XTS), [AES-XEX](https://en.wikipedia.org/wiki/Disk_encryption_theory#Xor%E2%80%93encrypt%E2%80%93xor_(XEX)), [AES-LRW](https://en.wikipedia.org/wiki/Disk_encryption_theory#Liskov,_Rivest,_and_Wagner_(LRW)) [AES-CMC](https://en.wikipedia.org/wiki/Disk_encryption_theory#CBC%E2%80%93mask%E2%80%93CBC_(CMC)_and_ECB%E2%80%93mask%E2%80%93ECB_(EME)), [AES-EME](https://en.wikipedia.org/wiki/Disk_encryption_theory#CBC%E2%80%93mask%E2%80%93CBC_(CMC)_and_ECB%E2%80%93mask%E2%80%93ECB_(EME)), and other wide block/disk encryption only modes: these are not suitable for encrypting data in transit. They should **only** be used for [disk encryption](https://en.wikipedia.org/wiki/Disk_encryption_theory), with **AES-XTS being preferred** since it’s popular, more secure than some other disk encryption modes, less malleable than AES-CBC and AES-CTR (tampering causes random, unpredictable changes to the plaintext), and ordinary authentication using an AEAD or Encrypt-then-MAC cannot be used for disk encryption because it would require extra storage and slow down read/write speeds, among other things.

9. [AES-GCM-SIV](https://en.wikipedia.org/wiki/AES-GCM-SIV) and [AES-SIV](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Synthetic_initialization_vector_(SIV)): these [don't](https://www.imperialviolet.org/2017/05/14/aesgcmsiv.html) provide unlimited protection against nonce reuse, they're slower than regular AES-GCM, they're rarely available in cryptographic libraries, they rely on Mac-then-Encrypt, and AES-SIV uses CMAC. If you need nonce-misuse resistance, then you should ideally use XChaCha20-then-MAC or XChaCha20-Poly1305 with a randomly generated nonce or a nonce derived alongside a subkey for encryption using a KDF or MAC, as described [here](https://doc.libsodium.org/secret-key_cryptography/encrypted-messages#nonce-misuse-resistance) and [here](https://doc.libsodium.org/secret-key_cryptography/encrypted-messages#short-nonces). If this isn’t possible for some reason, then use AES-GCM-SIV.

10. [(X)Salsa20](https://en.wikipedia.org/wiki/Salsa20) and [(X)Salsa20-Poly1305](https://doc.libsodium.org/secret-key_cryptography/secretbox): there’s no reason to use these when (X)ChaCha20 has [better diffusion and performance](https://cr.yp.to/chacha/chacha-20080128.pdf). However, (X)Salsa20 is still [very secure](https://en.wikipedia.org/wiki/Salsa20#Cryptanalysis_of_Salsa20). Also, as mentioned in point 4, you shouldn’t use (X)Salsa20 on its own (without a MAC) because **authentication is extremely important**.

#### Notes:
1. **Never reuse a nonce/IV with the same key (e.g. never hardcode a nonce/IV)**: doing so is **catastrophic** to security. You must either use a counter nonce, a KDF generated nonce/IV, or a randomly generated nonce/IV, depending on the algorithm you’re using. For instance, you should use a counter nonce (e.g. starting with 12 bytes of zeroes) with ChaCha20-Poly1305 and AES-GCM because the small nonce size (64- or 96-bits) means random nonces are **not** safe unless you're encrypting a small amount of data per key, but you can use a random or counter nonce safely with XChaCha20-Poly1305 because it has a large nonce size (192-bits). Then AES-CBC **requires** an unpredictable (aka random) 128-bit IV, and some implementations of AES-CTR need a random nonce too, although most involve using a 64- or 96-bit counter nonce for the reasons explained above. Note that if you always rotate the key before encrypting (**never** encrypting anything with the same key more than once), then you *can* get away with using a nonce full of zeroes (e.g. 12 bytes of zeroes for AES-GCM), but I generally wouldn’t recommend doing this, especially if you have to use a 128-bit key, which I again **don't** recommend (please see the [Symmetric Key Size](#symmetric-key-size) section), since this can lead to [multi-target attacks](https://blog.cr.yp.to/20151120-batchattacks.html).

2. Prepend the nonce/IV to the ciphertext: this is the recommended approach because it’s read before the ciphertext and doesn't need to be kept secret. However, if you're performing key wrapping (encrypting a key using another key), as described in point 6 below, then you could encrypt the nonce/IV too as an additional layer of protection.

3. **Never** use string variables for keys, nonces, IVs, and passwords: these parameters should **always** be byte arrays. **String keys are just passwords, meaning they're not suitable for use as keys directly** (please see the [Password Hashing/Password-Based Key Derivation](#password-hashingpassword-based-key-derivation) section). Furthermore, strings are immutable (unchangeable) in many programming languages (e.g. C#, Java, JavaScript, Go, etc), meaning they can’t be zeroed out from memory (please see point 7 below).

4. **Avoid** encryption functions/APIs that include a password parameter: these often use dated or [insecure](https://www.npmjs.com/package/evp_bytestokey) password-based KDFs that shouldn’t be used. Instead, use one of the recommended password-based KDFs (please see the [Password Hashing/Password-Based Key Derivation](#password-hashingpassword-based-key-derivation) section) yourself to derive an encryption key for an AEAD or an encryption key and MAC key for Encrypt-then-MAC.

5. AEADs often have limits on the amount of data they can safely encrypt using a single key: for AES-GCM, you can encrypt ~64 GiB using a key and nonce pair for one message (don't reuse the nonce, as explained in point 1 above) and ~350 GiB (assuming 16 KiB messages) with a single key. For ChaCha20-Poly1305-IETF, you can encrypt 256 GiB using a key and nonce pair for one message. XChaCha20-Poly1305 and the original ChaCha20-Poly1305 constructions have no practical limits (2^64+ bytes). Make sure you follow the recommendations below to ensure that these limits are never reached.

6. Ideally, use a new key for each message (except when chunking the same message, as explained in point 8 below): this helps prevent [cryptographic wear-out](https://soatok.blog/2020/12/24/cryptographic-wear-out-for-symmetric-encryption/) (using a single key to encrypt too much data), nonce reuse, and reusing keys with multiple algorithms whilst being beneficial for security in that a compromise of one key doesn’t compromise data encrypted under different keys. One common way of doing this is to randomly generate a unique data encryption key (DEK) for each message, encrypt the DEK using a key encryption key (KEK) derived using a key derivation function (KDF), and then prepend the encrypted DEK to the ciphertext. For decryption, you derive the KEK, use it to decrypt the encrypted DEK, and use the DEK to decrypt the ciphertext. Alternatively, you can derive unique keys using a random salt with a KDF, although this is inefficient when using a password-based KDF since it means a delay for every message.

7. Erase secret keys from memory as soon as possible: once you’ve finished using a secret key, it should be zeroed out from memory to prevent an attacker with physical or remote access to a machine being able to retrieve it. Note that in garbage collected programming languages, such as C#, Go, and JavaScript, this is difficult to achieve because the garbage collector can copy secrets around in memory. However, *attempting* to erase sensitive data from memory (e.g. [disabling compiler optimisations](https://github.com/samuel-lucas6/Kryptor/blob/2dada2ba7321a4284f6f9030ecb91c54c3e6291a/src/KryptorCLI/GeneralPurpose/Arrays.cs#L84) for the zero memory method) is better than doing nothing.

8. Encrypt large amounts of data in (16-64 KiB) chunks: this lowers memory usage, allows for more encryptions under the same key with AEADs, reduces theoretical [attack boundaries](https://doc.libsodium.org/secret-key_cryptography/aead#limitations) for AEADs, means that a corruption in a ciphertext might only affect one chunk rather than rendering the entire message unrecoverable, and enables the detection of tampered chunks before an entire message is sent or read. However, this is tricky to get right because you need to add and remove padding in the last chunk (e.g. using an encrypted header to store the length of padding or a padding scheme, as explained in point 13 below) and prevent chunks from being truncated (e.g. using the total ciphertext length as additional data), reordered, duplicated, or removed (e.g. using a counter nonce that's incremented for each chunk), so you should ideally use or replicate an existing API, like [secretstream()](https://doc.libsodium.org/secret-key_cryptography/secretstream) in libsodium.

9. **Don’t** *just* use a standardised AEAD (e.g. AES-GCM, ChaCha20-Poly1305, etc) if you’re performing password-based encryption in an **online scenario**: AEADs are **not** key committing, meaning they are susceptible to [partitioning oracle attacks](https://eprint.iacr.org/2020/1491.pdf), which [speed up password recovery](https://emilymstark.com/2021/02/01/padding-partitioning-oracles-and-another-hot-take-on-pakes.html). To solve this problem, you can either use Encrypt-then-MAC following the instructions later on in this Notes section, or you can apply a fix whilst still using an AEAD. Note that both methods will be slower than not having key commitment, but it's important to prevent this attack and the other issues explained in point 10 below. The fix I'd recommend involves deriving an encryption key and a MAC key using a KDF, encrypting the message using an AEAD with the encryption key, retrieving the authentication tag from the end of the ciphertext, and prepending a MAC of the encryption key, nonce, and AEAD authentication tag to the ciphertext (e.g. `HMAC(message: encryptionKey || nonce || tag, key: macKey)`). For decryption, you derive the encryption key and MAC key again, read the AEAD authentication tag, and verify the MAC in constant time (see point 17 below) before decrypting the message using the AEAD. An example of this fix can be found [here](https://github.com/samuel-lucas6/Committing-ChaCha20-Poly1305/tree/fb6b0c5aada36e011a6174daf52470d7784e1061/src/Method%202%20-%20Separate%20Keys%20for%20ChaCha20%20and%20Robustness%20Tag/CommittingChaCha20Poly1305).

10. Standardised AEADs (e.g. AES-GCM, ChaCha20-Poly1305, AES-GCM-SIV, etc) **aren’t** [key](https://doc.libsodium.org/secret-key_cryptography/aead#robustness) or [message](https://neilmadden.blog/2021/02/16/when-a-kem-is-not-enough/) committing: the lack of key commitment means that a ciphertext can be decrypted using **multiple keys** to [different but valid plaintexts](https://eprint.iacr.org/2020/1456.pdf). This won't reveal the original message, but it *could* result in the corruption of data or different plaintexts that appear to be valid file formats, which is not what you want. The [AWS Encryption SDK](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/introduction.html) now [recommends and defaults](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/best-practices.html) to using key commitment. As explained in point 9 above, this can especially cause problems when performing password-based encryption. To fix this problem, you should either use Encrypt-then-MAC instead or apply the fix for AEADs outlined above. The lack of message commitment means that an attacker who knows the key can find [other messages that have the same tag](https://neilmadden.blog/2021/02/16/when-a-kem-is-not-enough/), allowing them to trick two parties using the same key into believing that they received the same message when they actually [received different messages](https://www.reddit.com/r/crypto/comments/opm10n/do_i_need_a_key_committing_aead_to_be_random_key/h68mq3i/).

11. Make use of the additional data parameter in AEADs: this parameter is useful for binding context information to a ciphertext and preventing issues like [replay attacks](https://en.wikipedia.org/wiki/Replay_attack) and [confused deputy attacks](https://cloud.google.com/kms/docs/additional-authenticated-data#confused_deputy_attack_example). It’s often used to authenticate things like headers, version numbers, timestamps, and message counters. Note that additional data is not part of the ciphertext; it’s just information included in the computation of the authentication tag. You either need to store additional data securely in some sort of database (e.g. in the case of a user’s email address being used as additional data) or be able to reproduce the additional data when it’s time for decryption (e.g. using a file name as additional data).

12. If an attacker knows the encryption key, then they can still decrypt an AEAD encrypted message without knowing the additional data: for example, they can use AES-CTR with the key to decrypt an AES-GCM encrypted message, ignoring the authentication tag and additional data.

13. Pad messages before encryption if you want to hide their length: stream ciphers, such as ChaCha20 and AES-CTR (used in AES-GCM), don’t perform any padding, meaning the ciphertext is the same length as the plaintext. This generally isn’t a concern for most applications, but when it is, you should use [ISO/IEC 7816-4](https://en.wikipedia.org/wiki/Padding_(cryptography)#ISO/IEC_7816-4) or [PADME](https://bford.info/pub/sec/purb.pdf) padding on the message before encryption and remove the padding after decryption. These padding schemes are [more resistant to some types of attacks](https://doc.libsodium.org/padding#algorithm) than other padding algorithms and always reversible, unlike [zero padding](https://en.wikipedia.org/wiki/Padding_(cryptography)#Zero_padding). Such padding can be [randomised](https://en.wikipedia.org/wiki/Padding_(cryptography)#Randomized_padding) or [deterministic](https://en.wikipedia.org/wiki/Padding_(cryptography)#Deterministic_padding), with both techniques having pros and cons. Encrypting data in chunks, as described in point 8 above, is an example of deterministic padding since the last chunk will always be padded to the size of a chunk.

14. Stick to **Encrypt-then-MAC**: **don’t** MAC-then-Encrypt or Encrypt-and-MAC because both can be susceptible to attacks, whereas Encrypt-then-MAC is [always secure](https://crypto.stackexchange.com/questions/202/should-we-mac-then-encrypt-or-encrypt-then-mac) when implemented correctly. Encrypt-then-MAC is the standard approach and is what’s used in non-SIV (aka most) AEADs. The only exception to this rule is when implementing an SIV AEAD to have nonce-misuse resistance, but you should ideally let a library do that for you.

15. **Always** use separate keys for authentication and encryption: this is considered good practice, even though reusing the same key *can* be *theoretically* fine. In the case of a password-based KDF, this can be done by using a larger output length (e.g. 96 bytes) and splitting the output into two keys (e.g. 256-bit and 512-bit). In the case of a non-password-based KDF, you can use the KDF twice with the same input keying material but different context information, salts, and output lengths for domain separation. Please see the [Symmetric Key Size](#symmetric-key-size) section for details on what key size you should use for encryption and MACs.

16. **Always** MAC the nonce/IV (and everything in the message – e.g. file headers too): if you fail to authenticate the nonce/IV, then an attacker can tamper with it undetected. AEADs always authenticate the nonce for this reason.

17. **Always** compare secrets and MACs in constant time: if you don’t compare the authentication tags in constant time, then this can lead to timing attacks that allow an attacker to calculate a valid tag for a forged message. Libraries like libsodium have [constant time comparison functions](https://doc.libsodium.org/helpers#constant-time-test-for-equality) that you can use to prevent this.

18. Concatenating multiple variable length parameters when using a MAC (e.g. `HMAC(message: additionalData || ciphertext, key: macKey)`) can lead to **attacks**: please see point 5 of the [Message Authentication Codes](#message-authentication-codes) Notes section.

19. Cipher agility is [harmful](https://paragonie.com/blog/2019/10/against-agility-in-cryptography-protocols): less is more in the case of supporting multiple ciphers/algorithms because more choices means more can go wrong, which is one reason why [WireGuard](https://www.wireguard.com/) is regarded as superior to [OpenVPN](https://openvpn.net/) and TLS 1.3 supports [fewer algorithms](https://en.wikipedia.org/wiki/Transport_Layer_Security#Cipher) than TLS 1.2. Cipher agility has caused serious problems, like in the case of [JWTs](https://paragonie.com/blog/2017/03/jwt-json-web-tokens-is-bad-standard-that-everyone-should-avoid). Also, in the case of programs like [GPG](https://gnupg.org/) and [VeraCrypt](https://www.veracrypt.fr/), customisation allows the user to worsen their security. Therefore, **choose one secure Encrypt-then-MAC combo or AEAD recommended above, and that’s it**. If the algorithm you chose gets broken, which is **extremely** unlikely if you’re following these guidelines, then you can just increment the protocol/format version number and switch to a different algorithm.

20. Cascade encryption is unnecessary: although I’ve written a cascade encryption library based on [TripleSec](https://keybase.io/triplesec/) called [DoubleSec](https://github.com/samuel-lucas6/DoubleSec), cascade encryption is significantly slower and solves a problem that pretty much [doesn’t exist](https://blog.cryptographyengineering.com/2012/02/02/multiple-encryption/) because algorithms like ChaCha20 and AES are [nowhere near broken](https://eprint.iacr.org/2019/1492.pdf) and other issues are more likely to cause problems. Furthermore, it’s a hassle to implement yourself compared to using a single algorithm, with more things that can go wrong. Therefore, unless you’re extremely paranoid (e.g. in an Edward Snowden type situation) and don’t care about speed at all, please don’t bother.

#### Discussion:
Not everyone will agree with my recommendation to use Encrypt-then-MAC over AEADs when possible for the following reasons:

1. It’s easier to implement an AEAD: you don’t need to worry about deriving separate keys, appending and removing the authentication tag, and comparing authentication tags in constant time. AEADs also make it easy to use additional data in the calculation of the authentication tag. This should mean fewer mistakes.

2. AEADs are typically faster: AES-GCM with AES-NI instruction set support is very fast, AES-OCB is even faster, and ChaCha20-Poly1305 is also fast without the reliance on hardware support.

3. It’s easier to chunk data with an AEAD: Encrypt-then-MAC normally involves encrypting all the data in one go and appending one authentication tag at the end, which requires loading the entire message into memory and means a corruption renders the entire message unrecoverable. Whilst you can also do this with AEADs, it's recommended to chunk messages, as explained in point 8 of the Notes, meaning the ciphertext contains multiple authentication tags. This is trickier with Encrypt-then-MAC unless you're using a library that offers it as a function.

My response to these arguments is:

1. Yes, AEADs are simpler, which is exactly why we need committing AEADs and Encrypt-then-MAC implementations to be standardised and included in cryptographic libraries. Unfortunately, this isn’t happening because everyone is busy promoting non-committing AEADs.

2. Whilst this is often true, except for AES-GCM without AES-NI support, Encrypt-then-MAC, especially using MACs like BLAKE2b and BLAKE3, is not slow enough for this to be considered a serious problem, particularly in non-interactive/offline scenarios or when dealing with long-term storage. In fact, using BLAKE3 with a large enough amount of data can be faster than Poly1305 and GMAC. Moreover, I would argue that the additional security makes up for the loss in speed. (X)ChaCha20-Poly1305 and AES-GCM are not designed for long-term storage, whereas Encrypt-then-MAC is.

3. This is another reason why Encrypt-then-MAC implementations like (X)ChaCha20-BLAKE2b should be included in cryptographic libraries. If they were, then you could call it like any other AEAD. For instance, I made [ChaCha20-BLAKE2b](https://github.com/samuel-lucas6/ChaCha20-BLAKE2b) and [ChaCha20-BLAKE3](https://github.com/samuel-lucas6/ChaCha20-BLAKE3) libraries to allow me to do this.

So when should you use an AEAD? Exceptions to my Encrypt-then-MAC recommendation include when:

1. Maximum performance is necessary when using public-key cryptography: for example, in online scenarios that don’t involve passwords and storing data long-term, such as [TLS 1.3](https://www.davidwong.fr/tls13/) and [WireGuard](https://www.wireguard.com/protocol/). This is what AEADs are designed for.

2. You’re not comfortable implementing Encrypt-then-MAC: if there’s no decent library you can use (e.g. [Tink](https://developers.google.com/tink) isn’t available in your programming language) or copy code from (make sure you respect the code license!), then you’re more likely to implement an AEAD correctly. However, implementing the fix I recommend for partitioning oracle attacks (please see point 9 of the Notes), which affect online password-based encryption scenarios, requires knowing how to use a MAC, so at that point, you may as well use Encrypt-then-MAC, especially if you’re storing data long-term. The lack of key commitment could also *theoretically* lead to data loss even when partitioning oracle attacks aren't a threat (e.g. in offline scenarios), meaning you should also implement the fix if that concerns you, like Amazon has for their [Encryption SDK](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/best-practices.html). With enough research and attention to detail, Encrypt-then-MAC can be implemented correctly by anyone.

## Message Authentication Codes
#### Use (in order):
1. [Keyed BLAKE2b-256](https://doc.libsodium.org/hashing/generic_hashing) or [keyed BLAKE2b-512](https://doc.libsodium.org/hashing/generic_hashing): these are faster than HMAC, BLAKE (what BLAKE2 was on) received a [significant amount of cryptanalysis](https://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf), even more than Keccak (the SHA3 finalist), as part of the SHA3 competition, and BLAKE2b provides the [same practical level of security](https://eprint.iacr.org/2019/1492.pdf) as SHA3 whilst also being more popular in software (e.g. it’s used in [Argon2](https://www.rfc-editor.org/rfc/rfc9106.html#name-introduction) and many [other](https://www.blake2.net/#us) password hashing schemes).

2. [HMAC-SHA256](https://doc.libsodium.org/advanced/hmac-sha2) or [HMAC-SHA512](https://doc.libsodium.org/advanced/hmac-sha2): slower and older than BLAKE2b but [well-studied](https://en.wikipedia.org/wiki/SHA-2#Cryptanalysis_and_validation). SHA2 is also faster and far more available than SHA3, which has seen somewhat limited adoption so far since SHA2 is still secure.

3. [HMAC-SHA3-256](https://en.wikipedia.org/wiki/SHA-3) or [HMAC-SHA3-512](https://en.wikipedia.org/wiki/SHA-3): SHA3 is [slower](https://www.imperialviolet.org/2017/05/31/skipsha3.html) in software than BLAKE2b and SHA2 but has a [higher security margin](https://csrc.nist.gov/csrc/media/projects/hash-functions/documents/sha-3_selection_announcement.pdf) than both and is [fast](https://keccak.team/2017/is_sha3_slow.html) in hardware. Moreover, HMAC-SHA3 is needlessly inefficient because SHA3 is already a MAC. The only reason I’m recommending HMAC-SHA3 is because SHA3 is designed to be a replacement for SHA2, KMAC is rarely available, and you shouldn't have to construct a MAC using concatenation yourself in most scenarios.

4. [Keyed BLAKE3-256](https://github.com/BLAKE3-team/BLAKE3#readme): [faster](https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf) than HMAC, BLAKE2b, and SHA3, but it has a [smaller security margin](https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf), only targets the [128-bit security level](https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf), and hasn't been implemented in many cryptographic libraries yet.

#### Avoid (not in order because they’re all bad):
1. [HMAC-MD5](https://en.wikipedia.org/wiki/HMAC#Security) and [HMAC-SHA1](https://en.wikipedia.org/wiki/HMAC): MD5 and SHA1 should no longer be used for anything.

2. Regular, unencrypted hashes (e.g. `SHA256(ciphertext)`): this is **insecure** because unkeyed hashes don't provide authentication.

3. Regular, encrypted hashes (e.g. `AES-CTR(SHA256(ciphertext))`): this is **insecure**. For example, with a stream cipher, you could flip bits in the ciphertext hash.

4. `SHA2(key || message)`: this is **vulnerable** to [length extension attacks](https://en.wikipedia.org/wiki/Length_extension_attack), as discussed in point 3 of the Notes in the [Hashing](#hashing) section. Technically speaking, `SHA2(message || key)` works as a MAC if the attacker doesn’t know the key, but it’s weaker than constructions like HMAC because it requires the hash function to be collision resistant rather than a pseudorandom function and therefore shouldn’t be used. Newer hash functions, like BLAKE2b, SHA3, and BLAKE3, are resistant to length extension attacks and could be used to perform `Hash(key || message)` safely, but you should still just use a keyed hash function or HMAC instead to do the work for you.

5. [Poly1305](https://doc.libsodium.org/advanced/poly1305) and other polynomial MACs: these produce small tags that are designed for online protocols and small messages. They’re also easier to misuse than the recommended algorithms (e.g. Poly1305 requires a secret, unique, and unpredictable key each time that’s independent from the encryption key).

6. [CBC-MAC](https://en.wikipedia.org/wiki/CBC-MAC): this is unpopular and often [implemented incorrectly](https://blog.cryptographyengineering.com/2013/02/15/why-i-hate-cbc-mac/) because it has [weird requirements](https://en.wikipedia.org/wiki/CBC-MAC#Security_with_fixed_and_variable-length_messages) that most people are completely unaware of, **allowing for attacks**. Even when implemented correctly, the recommended algorithms are better.

7. [CMAC/OMAC](https://en.wikipedia.org/wiki/One-key_MAC): almost nobody uses this, even though it improves on CBC-MAC in terms of preventing mistakes.

8. 128-bit [keyed hashes](https://doc.libsodium.org/hashing/generic_hashing#usage) or [HMACs](https://en.wikipedia.org/wiki/HMAC): **you shouldn’t go below a 256-bit output** with hash functions because 128-bit security should be the minimum.

9. [KMAC](https://en.wikipedia.org/wiki/SHA-3#Additional_instances): whilst more efficient than HMAC-SHA3, it seems to be rarely available. Furthermore, it’s likely that HMAC-SHA3 will be the norm because SHA3 is designed to replace SHA2, which is used with HMAC.

#### Notes:
1. **Please read** points 14-17 of the [Symmetric Encryption](#symmetric-encryption) Notes for guidance on implementing a MAC correctly.

2. **Please read** point 2 of the [Symmetric Key Size](#symmetric-key-size) Use section for guidance on what key size to use.

3. A 256-bit authentication tag is sufficient for most use cases: however, a 512-bit tag provides additional security if you’re concerned about quantum computing. I wouldn’t recommend bothering with an output length in-between (e.g. HMAC-SHA384) because that’s not common, and you may as well go all the way to get a 256-bit security level.

4. Append the authentication tag to the ciphertext: this is common practice and how AEADs operate.

5. Concatenating multiple variable length parameters (e.g. `HMAC(message: additionalData || ciphertext, key: macKey)`) can lead to **attacks**: if you fail to concatenate the lengths of the parameters (e.g. `HMAC(message: additionalData || ciphertext || additionalDataLength || ciphertextLength, key: macKey)`, with the lengths converted to a fixed number of bytes consistently in either big- or little-endian, regardless of the endianness of the machine) or always ensure that they are fixed in size, then your implementation will be susceptible to [canonicalization attacks](https://soatok.blog/2021/07/30/canonicalization-attacks-against-macs-and-signatures/) because an attacker can shift bytes in the different parameters whilst producing a valid authentication tag. AEADs do this length concatenation for you to prevent this.

## Symmetric Key Size
#### Use (not in order because they have different use cases):
1. 256-bit keys: there’s essentially no reason not to use 256-bit keys for symmetric encryption. This is the only available key size for most (X)ChaCha20 and (X)Salsa20 implementations, it’s the key size that’s used for [top secret material](https://www.keylength.com/en/6/) by intelligence agencies and governments, and it’s [now recommended](https://www.keylength.com/en/3/) for long-term storage due to concerns surrounding quantum computers being able to bruteforce 128-bit keys.

2. 512-bit keys: if you’re using a MAC like HMAC-SHA512 or keyed BLAKE2b-512, then you should use a 512-bit key. This helps with domain separation when deriving keys, and it’s recommended to always use a key size as large as the output length for HMAC (e.g. a 256-bit key for HMAC-SHA256). This ensures that the key size doesn't decrease the security provided by the MAC.

#### Avoid (in order):
1. Smaller than 128-bit keys: this won’t stand the test of time and in some cases can already be bruteforced.

2. Symmetric encryption algorithms with large key sizes (e.g. [Threefish](https://en.wikipedia.org/wiki/Threefish)): anything over 256-bit is widely regarded as unnecessary. Furthermore, encryption algorithms supporting such key sizes are very unpopular in practice. Note that the situation is different for MACs, as explained in point 2 of the Use section above.

3. 128-bit keys: **this is the minimum**, but please just use 256-bit keys because they provide a higher security margin for an insignificant cost. The [argument](https://blog.1password.com/why-we-moved-to-256-bit-aes-keys/) that AES-128 is more secure than AES-256 due to certain attacks being more effective on AES-256 is incorrect because such attacks are **not** practical in the real world. You should ideally use ChaCha20 instead of AES anyway since it has a higher security margin and runs in constant time, avoiding timing attacks, as explained in the [Symmetric Encryption](#symmetric-encryption) Use section.

## Random Numbers
#### Use (in order):
1. The **cryptographically secure** pseudorandom number generator (CSPRNG) in your programming language or cryptographic library: these should use the operating system’s CSPRNG. For example, [RNGCryptoServiceProvider](https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rngcryptoserviceprovider?view=net-5.0) in C#.

2. [Fast key erasure](https://blog.cr.yp.to/20170723-random.html) **on embedded systems**: this should be **a last resort** because it’s hard to erase keys properly. **A lot can go wrong if you don’t know what you’re doing**. [Here's](https://github.com/WebAssembly/wasi-libc/blob/main/libc-top-half/sources/arc4random.c) an example ChaCha20 RNG implementation.

#### Avoid (not in order because they’re both bad):
1. A **non-cryptographically secure** pseudorandom number generator: for example, [Math.random()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random) in JavaScript, [Random.Next()](https://docs.microsoft.com/en-us/dotnet/api/system.random.next?view=net-5.0) in C#, [Random()](https://docs.oracle.com/javase/8/docs/api/java/util/Random.html) in Java, and so on. **These are not secure and should not be used for anything related to security**.

2. A custom RNG: this is **likely** going to be **insecure** because it’s harder to do properly than you’d think. **Just trust the operating system’s CSPRNG**.

## Hashing
#### Use (in order):
1. [BLAKE2b-512](https://doc.libsodium.org/hashing/generic_hashing) or [BLAKE2b-256](https://doc.libsodium.org/hashing/generic_hashing): fast, modern, as [real-world secure](https://eprint.iacr.org/2019/1492.pdf) as SHA3, BLAKE (what BLAKE2 was on) received a [significant amount of cryptanalysis](https://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf), even more than Keccak (the SHA3 finalist), as part of the SHA3 competition, and now quite popular in software (e.g. it’s used in [Argon2](https://www.rfc-editor.org/rfc/rfc9106.html#name-introduction) and many [other](https://www.blake2.net/#us) password hashing schemes).

2. [SHA512](https://en.wikipedia.org/wiki/SHA-2#Comparison_of_SHA_functions), [SHA512/256](https://en.wikipedia.org/wiki/SHA-2#Comparison_of_SHA_functions), or [SHA256](https://en.wikipedia.org/wiki/SHA-2#Comparison_of_SHA_functions): SHA2 is the most popular hash function, meaning it’s widely available in cryptographic libraries, it’s still secure besides [length extension attacks](https://en.wikipedia.org/wiki/Length_extension_attack) (please see point 3 of the Notes section), and it offers decent performance.

3. [SHA3-512](https://en.wikipedia.org/wiki/SHA-3#Comparison_of_SHA_functions) or [SHA3-256](https://en.wikipedia.org/wiki/SHA-3#Comparison_of_SHA_functions): [slow](https://www.imperialviolet.org/2017/05/31/skipsha3.html) in software, but the [new standard](https://www.nist.gov/publications/sha-3-standard-permutation-based-hash-and-extendable-output-functions), [fast](https://keccak.team/2017/is_sha3_slow.html) in hardware, and has a [higher security margin](https://eprint.iacr.org/2012/421.pdf) than the other algorithms listed here. If it was more common in software, then I would recommend it over SHA2 to prevent length extension attacks, but I’d still recommend BLAKE2b in such a case due to the improved software performance and equivalent security.

4. [BLAKE3-256](https://github.com/BLAKE3-team/BLAKE3#readme): the [fastest](https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf) cryptographic hash in software (assuming you don’t suffer from [performance issues in the main implementation](https://github.com/BLAKE3-team/BLAKE3/issues/31)) at the cost of having a [lower security margin](https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf) and being limited to a [128-bit security level](https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf). However, it improves on BLAKE2 in that there’s only one variant that covers all use cases (it’s a regular hash, PRF, MAC, KDF, and XOF), but depending on the cryptographic library you use, this isn’t necessarily something you’ll notice when using BLAKE2b anyway.

#### Avoid (not in order because they’re all bad):
1. **Non-cryptographic** hash functions and error-detecting codes (e.g. [CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check)): the clue is in the name. These are **not secure**.

2. [MD5](https://en.wikipedia.org/wiki/MD5) and [SHA1](https://en.wikipedia.org/wiki/SHA-1): both are very old and **no longer secure**. For instance, there’s an [attack](https://eprint.iacr.org/2013/170.pdf) that breaks MD5 collision resistance in 2^18 time. This takes less than a second to execute on an ordinary computer.

3. **Insecure** SHA3 competition candidates (e.g. [EDON-R](https://eprint.iacr.org/2009/378.pdf)): if you want to use something from the SHA3 competition, then you should either use BLAKE2b (based on BLAKE, which was thoroughly analysed and deemed to have a [very high security margin](https://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf)), SHA3 (the winner, very different to SHA2 in design, and has a [very high security margin](http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf)), or BLAKE3 (based on BLAKE2 but with a [lower security margin](https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf)).

4. [RIPEMD](https://en.wikipedia.org/wiki/RIPEMD): old, unpopular, most implementations are limited to small output lengths (e.g. 160-bit is the most common), and it has worse performance and has received less analysis compared to the recommended algorithms.

5. [Whirlpool](https://en.wikipedia.org/wiki/Whirlpool_(hash_function)), [SHA224](https://en.wikipedia.org/wiki/SHA-2#Comparison_of_SHA_functions), [Streetbog](https://en.wikipedia.org/wiki/Streebog), [MD6](https://en.wikipedia.org/wiki/MD6), and other hashes nobody uses: these are all worse in one way or another than the recommended algorithms, which is why nobody uses them. For instance, Whirlpool is [slower](https://www.cryptopp.com/benchmarks.html) than most other cryptographic hash functions, SHA224 only provides [112-bit collision resistance](https://en.wikipedia.org/wiki/SHA-2#Comparison_of_SHA_functions), which is below the recommended 128-bit security level, Streetbog has a [poor S-Box design with no design rational ever being made public](https://eprint.iacr.org/2016/071.pdf), MD6 didn't make it to the [second round](https://competitions.cr.yp.to/sha3.html) of the SHA3 competition and has [speed issues](https://en.wikipedia.org/wiki/MD6), and so on.

6. Chaining hash functions (e.g. `SHA256(SHA1(message))`): this can be **insecure** (e.g. SHA1 has worse collision resistance than SHA256, meaning a collision for SHA1 results in a collision for `SHA256(SHA1(message))`) and is obviously less efficient than hashing once. **Just don’t do this**.

7. 128-bit hashes: you shouldn’t go below a 256-bit output with hash functions to ensure 128-bit security.

#### Notes:
1. **These hash functions are not suitable for password hashing**: these algorithms are fast, whereas password hashing needs to be slow to prevent [bruteforce attacks](https://en.wikipedia.org/wiki/Password_cracking). Furthermore, password hashing requires using a **random** salt for each password to derive unique hashes when given the same input and to protect against attacks using [precomputed hashes](https://en.wikipedia.org/wiki/Rainbow_table).

2. **These unkeyed hash functions are not suitable for authentication**: you need to use [MACs](https://en.wikipedia.org/wiki/Message_authentication_code) (please see the [Message Authentication Codes](#message-authentication-codes) section), such as keyed BLAKE2b-512 and HMAC-SHA512, for authentication because they provide the [appropriate security guarantees](https://en.wikipedia.org/wiki/Message_authentication_code#Security).

3. **SHA2** (except for SHA512/256 – SHA224 and SHA384 [don’t provide the same level of protection](https://en.wikipedia.org/wiki/SHA-2#Comparison_of_SHA_functions)), MD5, SHA1, Whirlpool, RIPEMD-160, and MD4 are [susceptible to length extension attacks](https://en.wikipedia.org/wiki/Length_extension_attack): an attacker can use `Hash(message1)` and the length of `message1` to calculate `Hash(message1 || message2)`, with `message2` being controlled by the attacker, without knowing what `message1` is. Therefore, **concatenating things (e.g. `Hash(secret || message)`) with these algorithms is a bad idea**. Instead, BLAKE2b, SHA512/256, HMAC-SHA2, SHA3, HMAC-SHA3, or BLAKE3 should be used because none of these are susceptible to length extension attacks. Also, please read point 5 of the [Message Authentication Codes](#message-authentication-codes) Notes section because concatenating parameters incorrectly can lead to another type of attack.

## Password Hashing/Password-Based Key Derivation
#### Use (in order):
1. [Argon2id](https://en.wikipedia.org/wiki/Argon2) (64+ MiB of RAM, 3+ iterations, and 1+ parallelism): winner of the [Password Hashing Competition](https://www.password-hashing.net/) in 2015, widely used and recommended now, and very [easy to use](https://doc.libsodium.org/password_hashing/default_phf) in libraries like libsodium. Use as high of a memory size as possible and then as many iterations as possible to reach a suitable delay for your use case (e.g. a delay of 500 milliseconds for server authentication, 1 second for file encryption, 3-5 seconds for disk encryption, etc).

2. [scrypt](https://en.wikipedia.org/wiki/Scrypt) (N=32768, r=8, p=1 and higher): the parameters are more confusing and less scalable than Argon2, and it’s susceptible to [cache-timing attacks](https://crypto.stanford.edu/cs359c/17sp/projects/MarkAnderson.pdf). However, it’s still a [strong algorithm](https://www.tarsnap.com/scrypt/scrypt.pdf) when configured correctly.

3. [bcrypt](https://en.wikipedia.org/wiki/Bcrypt) (12+ work factor): note that **this is not a KDF** because the output length cannot be adjusted. **Only use this for password hashing when none of the better algorithms are available**. It’s better than PBKDF2 in terms of [resisting GPU/ASIC attacks](https://www.tarsnap.com/scrypt/scrypt.pdf), except for long passwords (please keep reading), but trickier to implement correctly and worse than Argon2 and scrypt in that it requires much less memory, with the amount of memory being fixed rather than adjustable. Unfortunately, it only uses the [first 55 characters of a password](https://www.tarsnap.com/scrypt/scrypt.pdf) and has a stupid password length limit of [72 characters](https://en.wikipedia.org/wiki/Bcrypt#Maximum_password_length), meaning people often prehash the password using something like SHA2 to support longer passwords. However, this can lead to [password shucking](https://www.youtube.com/watch?v=OQD3qDYMyYQ) when using a weak hash function (e.g. MD5, which should **never** be used for anything anyway) and null bytes in the hash allowing an attacker to find [collisions](https://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html), speeding up attacks. Therefore, you should [Base64 encode the prehash](https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence) before passing it to bcrypt.

4. [PBKDF2-SHA512](https://en.wikipedia.org/wiki/PBKDF2) (120,000+ iterations): **only use this when none of the better algorithms are available** or due to compatibility restraints because it can be [efficiently bruteforced](https://www.tarsnap.com/scrypt/scrypt.pdf) using GPUs and ASICs when not using a high iteration count. Note that it’s generally recommended not to ask for more than the output length of the underlying hash function because this can lead to [attacks](https://blog.1password.com/1password-hashcat-strong-master-passwords/). Instead, if that’s required, use PBKDF2 first to get the output length of the underlying hash function (64 bytes with PBKDF2-SHA512) before calling a non-password-based KDF, like HKDF-Expand, with the PBKDF2 output as the input keying material (IKM) to derive more output.

#### Avoid (not in order because they’re all bad):
1. Storing passwords in plaintext: **this is a recipe for disaster**. If your password database is ever compromised, all your users are screwed, and your reputation in terms of security will go down the drain as well.

2. Using a password as a key (e.g. `key = Encoding.UTF8.GetBytes(password)`): firstly, passwords are low in entropy, whereas **cryptographic keys need to be high in entropy**. Secondly, not using a password-based KDF with a random salt means **attackers can quickly bruteforce passwords** and users using the same password will end up using the same key.

3. Using a regular/fast hash function (e.g. [MD5](https://en.wikipedia.org/wiki/MD5), [SHA1](https://en.wikipedia.org/wiki/SHA-1), [SHA2](https://en.wikipedia.org/wiki/SHA-2), etc): **these are not suitable for password hashing** because they’re not slow, which allows for **fast bruteforce attacks**. Password hashing also requires using a salt to protect against attacks using precomputed hashes and to prevent the same password always having the same hash. However, adding a salt to certain regular hash functions, such as SHA2, can lead to [length extension attacks](https://en.wikipedia.org/wiki/Length_extension_attack), as discussed in point 3 of the Notes in the [Hashing](#hashing) section.

4. Encrypting passwords: **encryption is reversible, whereas hashing is not**. If an attacker compromises a password database and obtains a password hash, then they don’t know the password without computing the hash. By contrast, if an attacker compromises a password database and the relevant encryption key(s), then they can easily obtain the plaintext passwords. Encryption would also reveal the password length unless you padded the input.

5. [PBKDF1](https://en.wikipedia.org/wiki/PBKDF2): **never use this** as it was **superseded by PBKDF2** and can only derive keys up to 160-bits, which is basically not suitable for anything. Some implementations, such as [PasswordDeriveBytes()](https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.passwordderivebytes?view=net-5.0) in C#, are also [completely broken](https://crypto.stackexchange.com/questions/1842/how-does-pbkdf1-work).

6. [SHAcrypt](https://en.wikipedia.org/wiki/Crypt_(C)#SHA2-based_scheme): it's [weaker](https://www.akkadia.org/drepper/SHA-crypt.txt) than the recommended algorithms, nobody uses this, and I’ve never even seen it in a cryptographic library.

7. [PBKDF2-MD5](https://en.wikipedia.org/wiki/PBKDF2), [PBKDF2-SHA1](https://en.wikipedia.org/wiki/PBKDF2), [PBKDF2-SHA256](https://en.wikipedia.org/wiki/PBKDF2), and [PBKDF2-SHA384](https://en.wikipedia.org/wiki/PBKDF2): **use SHA512 if you must use PBKDF2**. MD5 and SHA1 are old hash functions that **should not be used anymore**. Then PBKDF2-SHA256 and PBKDF2-SHA384 require [significantly more iterations](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#pbkdf2) than PBKDF2-SHA512 to be secure and have a smaller block size, meaning long passwords may get prehashed.

8. [Argon2i](https://en.wikipedia.org/wiki/Argon2) with less than 3 iterations: unlike Argon2id and Argon2d, Argon2i has been [attacked](https://en.wikipedia.org/wiki/Argon2#Cryptanalysis), with [3+ iterations](https://mailarchive.ietf.org/arch/msg/cfrg/beOzPh41Hz3cjl5QD7MSRNTi3lA/) being required for the attack to not be efficient and [11+ iterations](https://eprint.iacr.org/2016/759.pdf) being required for the attack to completely fail. Argon2i is also [weaker](https://www.rfc-editor.org/rfc/rfc9106.html#name-security-against-time-space) than both Argon2id and Argon2d when it comes to resistance against GPU/ASIC cracking. Therefore, as per the RFC (https://www.rfc-editor.org/rfc/rfc9106.html), Argon2id should be used if you do not know the difference between the types or you consider side-channel attacks to be a viable threat because Argon2id offers the benefits of both Argon2i (side-channel resistance, albeit to a lesser extent) and Argon2d (GPU/ASIC resistance).

9. Chaining password hashing functions (e.g. `scrypt(PBKDF2(password))`): **this just reduces the strength of the stronger algorithm** since it means having worse parameters to get the same total delay.

#### Notes:
1. **Never hard-code passwords into source code**: these can be easily retrieved.

2. **Always use a random 128-bit or 256-bit salt**: salts ensure that each password hash is different, which prevents an attacker from identifying two identical passwords without cracking the hashes. Moreover, salting defends against [attacks](https://en.wikipedia.org/wiki/Password_cracking) that rely on [precomputed hashes](https://en.wikipedia.org/wiki/Rainbow_table). The typical salt size is 128-bits, but 256-bit is also fine for further reassurance that the salt won’t repeat. Anything above that is excessive, and short salts can lead to salt reuse and allow for precomputed attacks, which defeats the point of salting.

3. **Always use the highest parameters/delay you can afford**: ideally, use a delay of 250+ milliseconds. In many cases, that’s too small. For instance, PBKDF2 requires a high number of iterations because it’s not resistant to GPU/ASIC attacks, and if you’re performing a non-interactive operation (e.g. disk encryption), then you can afford longer delays like 3-5 seconds.

4. **Avoid** string password variables: strings are immutable (unchangeable) in many programming languages (e.g. C#, Java, JavaScript, Go, etc), meaning they can’t be zeroed out from memory. Instead, use a char array if possible and convert that into a byte array for password hashing/password-based key derivation. Then erase both arrays from memory after you’ve finished using them. Note that this is also difficult in many programming languages, as explained in point 7 of the [Symmetric Encryption](#symmetric-encryption) Notes section, but *attempting* to erase sensitive data from memory is better than doing nothing.

5. Compare passwords in **constant time**: if you ever need to compare passwords (e.g. for password re-entry in a console application), then you should use a constant time comparison function to prevent [timing attacks](https://en.wikipedia.org/wiki/Timing_attack). Sometimes these functions require both arrays to be equal in length, in which case you can hash both passwords using a regular hash function (e.g. BLAKE2b-512) for the comparison; just erase these values from memory afterwards and don’t use them for anything else.

6. Use a 256-bit and above output length: for password storage, a 128-bit hash is normally fine, but a 256-bit output provides a better security level for high entropy passwords. For key derivation, you should derive at least a 256-bit output and perhaps more, depending on whether you need to derive multiple keys (e.g. a 256-bit encryption key and a 512-bit MAC key).

7. **Always** store the parameters (e.g. memory size, iterations, and parallelism for Argon2) with the password hash: these values don't need to be secret and are required to derive the correct hash. When storing passwords in a database, you should store these values for each user in order to verify the hashes and transition to stronger parameters over time as hardware improves. In [some](https://doc.libsodium.org/password_hashing/default_phf#password-storage) cryptographic libraries, this is done for you. By contrast, in a key derivation scenario, you can get away with using fixed parameters based on a version number stored as a header (e.g. file format v3 = 256 MiB of RAM and 12 iterations). Then if you want to change the parameters, you just increment the version number.

8. **Perform client-side password prehashing** for [server relief](https://doc.libsodium.org/password_hashing#server-relief) or to [hide the plaintext password from the server](https://bitwarden.com/help/article/what-encryption-is-used/#pbkdf2): when creating an account, the server can send a **random** salt to the client that’s used to perform password hashing on the client’s device. The server then performs server-side password hashing on the transmitted password hash using the same salt. Then the salt and final password hash are stored in the password database. When logging in, the server sends the stored salt to the client, the client performs client-side password hashing, the client transmits the password hash to the server, the server performs server-side password hashing using the stored salt, and then the server compares the result with the password hash stored in the database. In the event of a non-existent user, the salt that’s sent should always be the same for a given username, which involves using a MAC (e.g. keyed BLAKE2b-512), with the username as the message.

9. **Don’t** use padding to hide the length of a password when sending it to a server: instead, perform client-side password hashing if possible (please see point 8 above). If that’s not possible, then you should hash the password using a regular hash function, with the largest possible output length (e.g. BLAKE2b-512), on the client’s device, transmit the hash to the server, and perform server-side password hashing, using the transmitted hash as the password. Both techniques ensure that the amount of data transmitted is constant and prevent the server [effortlessly](https://about.fb.com/news/2019/03/keeping-passwords-secure/) obtaining a copy of the password, but client-side password prehashing should be preferred as it allows for more secure password hashing parameters and provides additional security compared to if the server leaks/stores the client-side regular/fast hash of the password.

10. **Use** [rate limiting](https://www.cloudflare.com/en-gb/learning/bots/what-is-rate-limiting/) to prevent denial of service (DOS) and bruteforce attacks: this involves blacklisting certain IP addresses and usernames from trying to log in temporarily to prevent the server being overwhelmed and to prevent attackers from bruteforcing passwords.

11. If a user can supply very long passwords, then this *can* lead to denial of service attacks: this happened to [Django](https://www.djangoproject.com/weblog/2013/sep/15/security/) in 2013. To fix this, either enforce a password length limit (e.g. 128 characters is the max) or prehash passwords using a regular/fast hashing algorithm, with the highest possible output length (e.g. BLAKE2b-512), before performing password hashing.

12. [Hash-then-Encrypt](https://github.com/paragonie/password_lock#readme) for additional security when storing passwords: you can use a **password hashing algorithm** on the password before encrypting the salt and password hash using an AEAD or Encrypt-then-MAC, with a secret key **stored separately from the password database**. This forces an attacker to decrypt the password hashes before trying to crack them. Furthermore, it means that if your secret key is ever compromised but the password hashes are not, then you can decrypt all the stored password hashes and re-encrypt them using a new key, which is easier than resetting every user’s password in the event of a pepper being compromised.

13. Use a [pepper](https://en.wikipedia.org/wiki/Pepper_(cryptography)) for additional security when deriving keys: a pepper is essentially a secret key that’s mixed with the password using a MAC (e.g. `HMAC-SHA512(message: password, key: pepper)`) before password hashing. In the case of password storage, using Hash-then-Encrypt makes more sense for the reason I explained above. By contrast, for key derivation, using a pepper is a great idea if possible because it means an additional secret is required, making a bruteforce more difficult. For instance, a keyfile in [file](https://www.kryptor.co.uk/tutorial#using-a-keyfile)/[disk](https://veracrypt.fr/en/Keyfiles%20in%20VeraCrypt.html) encryption software acts as a pepper, which improves the security of the key derivation assuming that the keyfile is stored correctly (e.g. on an encrypted memory stick away from the encrypted file/disk).

## (Non-Password-Based) Key Derivation Functions
#### Use (in order):
1. [Salted BLAKE2b](https://doc.libsodium.org/key_derivation): [restricted](https://www.blake2.net/blake2.pdf) to a 128-bit salt and 128-bit (16 character) personalisation parameter for domain separation, which is annoying. However, you can feed more context information into the message parameter. Besides the weird personal size limit, this is easier to use than HKDF because there’s only one function rather than three, which can be confusing. Furthermore, please see the [Hashing](#hashing) section for why BLAKE2b should be preferred over other hash functions. If there's no KDF variant of BLAKE2b available in your library, then you should probably use HKDF (please see below). However, **if you know what you're doing**, you can construct a BLAKE2b KDF using `BLAKE2b(message: salt || info || saltLength || infoLength, key: inputKeyingMaterial)`, with the `saltLength` and `infoLength` parameters being encoded as specified in point 5 of the [Message Authentication Codes](#message-authentication-codes) Notes section. Like HKDF, this custom approach allows for salt and info parameters of practically any length.

2. [HKDF-SHA512](https://en.wikipedia.org/wiki/HKDF) or [HKDF-SHA3-512](https://en.wikipedia.org/wiki/HKDF): the most popular KDF with support for a larger salt and lots of context information. However, people get confused about the difference between the Expand and Extract functions, it doesn’t require a salt despite it being [recommended and beneficial for security](https://datatracker.ietf.org/doc/html/rfc5869#section-3.1), and it’s slower than salted BLAKE2b. Please see the [Hashing](#hashing) and [Message Authentication Codes](#message-authentication-codes) sections for a comparison between SHA2/SHA3 and HMAC-SHA2/HMAC-SHA3.

3. [BLAKE3](https://github.com/BLAKE3-team/BLAKE3/#the-blake3-crate-): as mentioned before, BLAKE3 has a [lower security margin](https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf), but it also doesn’t have a salt parameter. With that said, [very good guidance](https://github.com/BLAKE3-team/BLAKE3#the-blake3-crate-) is given on how to produce globally unique and application specific context strings in the [official GitHub repo](https://github.com/BLAKE3-team/BLAKE3). If you'd like a salt parameter, then you can construct a custom KDF implementation as explained in point 1 above.

#### Avoid (not in order because they’re all bad):
1. Regular (salted or unsalted) hash functions: whilst this *can* be fine for deriving an encryption key from a Diffie-Hellman shared secret for example, it’s typically **not recommended**. Just use an actual KDF when possible as there’s less that can go wrong (e.g. there's no risk of [length extension attacks](https://en.wikipedia.org/wiki/Length_extension_attack)).

2. Password-based KDFs (e.g. [PBKDF2](https://en.wikipedia.org/wiki/PBKDF2)): if you’re not using a password, then you shouldn’t be using a password-based KDF. Password-based KDFs are designed to be slow to prevent [bruteforce attacks](https://en.wikipedia.org/wiki/Brute-force_attack), whereas non-password-based KDFs are fast because they're designed for high-entropy keys. Even with a small delay (e.g. 1 iteration of PBKDF2), this is likely slower and makes the code more confusing because an inappropriate function is being used.

3. [HChaCha20](https://doc.libsodium.org/key_derivation#nonce-extension) and [HSalsa20](https://cr.yp.to/snuffle/xsalsa-20110204.pdf): **these are not general-purpose cryptographic hash functions**, can only take a 256-bit key as input and output a 256-bit key, and are very rarely used, except in the case of implementing XChaCha20 and XSalsa20. If you want something based on ChaCha, then use BLAKE2b or BLAKE3.

#### Notes:
1. **These KDFs are not suitable for hashing passwords**: they should be used for deriving multiple subkeys from a **high-entropy** master key or converting a shared secret into a cryptographically strong secret key.

2. Using the same parameters besides changing the output length can result in related outputs (e.g. for HKDF and BLAKE3): this is exactly why you shouldn’t reuse the same parameters for different keys.

3. Use different contexts for different keys: a good format is `[application] [date and time] [purpose]` because this means the context information is application-specific and unique, which provides domain separation.

4. Salted BLAKE2b can use a **counter** salt: if you’re deriving multiple subkeys from a master key, then you can use a counter salt starting at 0 (16 bytes of 0s) that gets incremented for each subkey. However, if you’re deriving a single key (e.g. from a shared secret), then you should use a random salt.

5. Use a **random** salt with HKDF when possible: the [RFC](https://datatracker.ietf.org/doc/html/rfc5869#section-3.1) explains that using a random salt adds to the security of the scheme. The authors recommend a salt as long as the hash output length, but a 128-bit or 256-bit salt is sufficient. Using a secret salt (a bit like a [pepper](https://en.wikipedia.org/wiki/Pepper_(cryptography)) further improves the security guarantees.

## Key Exchange/Hybrid Encryption
#### Use (in order):
1. [Curve25519/X25519](https://en.wikipedia.org/wiki/Curve25519): popular, fast, easy to implement, fixes some issues with NIST curves, not designed by NIST, and offers ~128-bit security.

2. [Curve448/X448](https://en.wikipedia.org/wiki/Curve448): less popular and slower than X25519 but provides a 224-bit security level and is also not made by NIST.

3. [Pre-shared symmetric keys](https://en.wikipedia.org/wiki/Pre-shared_key): this approach allows for [post-quantum security](https://media.defense.gov/2021/Aug/04/2002821837/-1/-1/1/Quantum_FAQs_20210804.PDF) and can be combined [alongside](https://www.wireguard.com/protocol/#key-exchange-and-data-packets) an asymmetric key exchange. However, using pre-shared keys can be difficult since the key must be kept secret, whereas public keys are meant to be public and can therefore be easily shared.

#### Avoid (not in order because they’re all bad):
1. [Plain RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Attacks_against_plain_RSA), [RSA PKCS#1 v1.5](https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Padding_schemes), [RSA-KEM](https://en.wikipedia.org/wiki/Key_encapsulation), and [RSA-OAEP](https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding): plain/textbook RSA is **insecure** for [several reasons](https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Attacks_against_plain_RSA), RSA PKCS#1 v1.5 is also **vulnerable** to some [attacks](https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Padding_schemes), and RSA-KEM and RSA-OAEP, whilst both secure *when* [implemented correctly](https://paragonie.com/blog/2018/04/protecting-rsa-based-protocols-against-adaptive-chosen-ciphertext-attacks), are still **worse than using hybrid encryption** because asymmetric encryption is slower, designed for small messages, doesn’t provide sender authentication without signatures, and requires larger keys. RSA-KEM is also never used and very rarely available in cryptographic libraries.

2. [ElGamal](https://en.wikipedia.org/wiki/ElGamal_encryption): old, very rarely used, can only be used on small messages, produces a ciphertext that’s larger than the plaintext, the design is [malleable](https://en.wikipedia.org/wiki/Malleability_%28cryptography)), it's slower than hybrid encryption, and it doesn’t provide sender authentication without signatures.

3. [NIST curves](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography#Fast_reduction_(NIST_curves)) (e.g. P-256, P-384, and P-512): although P-256 is probably the most popular curve, the seeds for these curves [haven’t been explained](https://datatracker.ietf.org/doc/html/rfc8031#section-4), which is [not a good look](https://safecurves.cr.yp.to/rigid.html) considering that [Dual_EC_DRBG](https://en.wikipedia.org/wiki/Dual_EC_DRBG) was a NIST standard despite containing an [NSA backdoor](https://en.wikipedia.org/wiki/Dual_EC_DRBG#Weakness:_a_potential_backdoor). Furthermore, these curves require [point validation](https://crypto.stackexchange.com/questions/51320/ecdh-check-points), are [harder to write implementations for](https://safecurves.cr.yp.to/), meaning libraries are more likely to contain vulnerabilities, and are slower than Curve25519/X25519, which has become increasingly popular over recent years (e.g. it's used in [TLS 1.3](https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_1.3)). **These should only be used for interoperability reasons**.

4. Other curves (e.g. [Curve41417](https://eprint.iacr.org/2014/526.pdf)): these are often [rarely used/available](https://en.wikipedia.org/wiki/Comparison_of_TLS_implementations#Supported_elliptic_curves) compared to Curve25519/X25519, P-256, P-384, and P-512. Please see the [SafeCurves](https://safecurves.cr.yp.to/index.html) tables for a security comparison of most curves.

5. [SRP](https://en.wikipedia.org/wiki/Secure_Remote_Password_protocol), [J-PAKE](https://en.wikipedia.org/wiki/Password_Authenticated_Key_Exchange_by_Juggling), and other [PAKE](https://en.wikipedia.org/wiki/Password-authenticated_key_agreement) protocols: note that these are only for password-based authenticated key exchange. SRP has an [odd design](https://blog.cryptographyengineering.com/should-you-use-srp/), no security proof, leaks the salt to untrusted users, requires more bandwidth and computation than [ECDH](https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman), and old versions contained vulnerabilities. Some PAKEs require the user to store the password on the server or reveal the salt to an attacker, allowing for [pre-computation attacks](https://blog.cryptographyengineering.com/2018/10/19/lets-talk-about-pake/). Furthermore, very few cryptographic libraries include PAKEs, which makes good ones, like [OPAQUE](https://blog.cryptographyengineering.com/2018/10/19/lets-talk-about-pake/), difficult to recommend [until they receive more adoption](https://blog.cloudflare.com/opaque-oblivious-passwords/).

6. [Post-quantum algorithms](https://csrc.nist.gov/projects/post-quantum-cryptography): these are still being researched, aren’t implemented in mainstream libraries, are much slower than existing algorithms, and typically have very large key sizes. However, it will eventually make sense to switch to one in the future. For now, if post-quantum security is a goal, then use a pre-shared symmetric key if possible.

#### Notes:
1. Public keys should be shared, and **private keys must be kept secret**: **never** share private keys. Please see point 9 below for details about secure storage of private keys.

2. **Never hard-code private keys into source code**: these can be easily retrieved.

3. For hybrid encryption, use one of the recommended key exchange algorithms above with one of the recommended [symmetric encryption algorithms](#symmetric-encryption): for example, use X25519 with ChaCha20-Poly1305.

4. Use one of the recommended (non-password-based) KDFs on the shared secret: **shared secrets are not suitable for use as secret keys directly** because they’re not uniformly random. Moreover, you should derive unique keys each time by using the salt and context parameters, as explained in the [(Non-Password-Based) Key Derivation Functions](#non-password-based-key-derivation-functions) section.

5. When using counter nonces for encryption, use different keys for different directions in a client-server scenario: after computing the shared secret, you can use a non-password-based KDF to derive two 256-bit keys as follows: `HKDF-SHA512(inputKeyingMaterial: sharedSecret, outputLength: 64, salt: null, info: clientPublicKey || serverPublicKey)`, splitting the output in two. One key should be used by the client for sending data to the server, and the other should be used by the server for sending data to the client. Both keys need to be calculated by the client and server. This approach allows counter nonces to be used [safely](https://doc.libsodium.org/key_exchange#notes) for encryption without having to wait for an acknowledgement after every message.

6. X25519 and X448 public keys can be distinguished from random data: if you need to obfuscate public keys so that they’re indistinguishable from random noise, then you need to use [Elligator 2](https://elligator.cr.yp.to/). Note that other metadata (e.g. the number of bytes in a packet) can reveal the use of cryptography too, so you should consider padding such information using a scheme like [PADME](https://bford.info/pub/sec/purb.pdf).

7. Use an **authenticated key exchange** in most non-interactive/offline protocols: the Noise protocol framework K and X one-way handshake [patterns](http://noiseprotocol.org/noise.html#one-way-handshake-patterns), as explained [here](https://neilmadden.blog/2018/11/26/public-key-authenticated-encryption-and-why-you-want-it-part-ii/), are perfect for non-interactive/offline protocols. These achieve sender and recipient authentication whilst preventing a compromise of the sender’s private key leading to an attacker being able to decrypt the ciphertext.

8. Opt for **forward secrecy** when possible in interactive/online protocols: this prevents a compromise of a long-term private key leading to a compromise of a session key, which is the strongest security guarantee you can achieve. This can be implemented using the Noise KK or IK interactive [handshakes](https://noiseprotocol.org/noise.html#interactive-handshake-patterns-fundamental).

9. **Store private keys encrypted**: when storing a private key in a file, you should always encrypt it with a strong password for protection at rest. Things become more complicated for interactive/online scenarios, with physical or virtual [hardware security modules (HSMs)](https://en.wikipedia.org/wiki/Hardware_security_module) and key vaults, such as [AWS Key Management Service (KMS)](https://aws.amazon.com/kms/), sometimes being used. These types of solutions are generally regarded as more secure than storing keys in encrypted configuration files and allow for easy key rotation, but using a KMS requires trusting a third party.

10. Key pairs should be rotated: if a private key has or may have been compromised, then a new key pair should be generated. Similarly, you should consider rotating your keys after a set period of time (a [cryptoperiod](https://en.wikipedia.org/wiki/Cryptoperiod)) has elapsed.

## Digital Signatures
#### Use (in order):
1. [Ed25519](https://en.wikipedia.org/wiki/EdDSA): very popular, accessible, fast, uses small keys, produces small signatures, deterministic, and offers ~128-bit security.

2. [Ed448](https://en.wikipedia.org/wiki/EdDSA#Ed448): less popular and slower than Ed25519 but uses SHAKE256 (a SHA3 variant) instead of SHA512 for hashing and edwards448 instead of edwards25519 for the curve, meaning a 224-bit security level.

#### Avoid (not in order because they’re all bad):
1. [Plain RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Attacks_against_plain_RSA), [RSA-PKCS#1 v1.5](https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Padding_schemes), and [RSA-PSS](https://en.wikipedia.org/wiki/Probabilistic_signature_scheme): plain RSA is [insecure](https://crypto.stackexchange.com/questions/20085/which-attacks-are-possible-against-raw-textbook-rsa), RSA-PKCS#1 v1.5 has [no security proof](https://en.wikipedia.org/wiki/Probabilistic_signature_scheme) and is [no longer recommended in the RFC](https://tools.ietf.org/html/rfc8017#section-8), and RSA-PSS is slow for signing and generating keys, produces larger signatures, and requires larger keys than [ECC](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography) based signing algorithms. Moreover, RSA has [implementation traps](https://crypto.stanford.edu/~dabo/papers/RSA-survey.pdf).

2. [ElGamal](https://en.wikipedia.org/wiki/ElGamal_signature_scheme): old, even slower than RSA, not included in cryptographic libraries, basically not used in any software, not standardised, produces large signatures, and if the message is used directly rather than hashed, as specified in the [original paper](https://caislab.kaist.ac.kr/lecture/2010/spring/cs548/basic/B02.pdf), then that allows for [existential forgery](https://en.wikipedia.org/wiki/ElGamal_signature_scheme#Security).

3. [DSA](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm): very old, becoming less and less supported, typically used with an [insecure key size](https://buttondown.email/cryptography-dispatches/archive/cryptography-dispatches-dsa-is-past-its-prime/), slower than Ed25519, requires larger keys than [ECC](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography), and it's not deterministic, which has led to [serious vulnerabilities](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm#Security) (please see below).

4. [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm): slower than Ed25519 and not deterministic, which has led to [serious vulnerabilities](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm#Security) that affected Sony’s PS3 and Bitcoin, allowing attackers to recover private keys. This issue can be prevented by properly generating a random nonce, which requires having a good [CSPRNG](https://en.wikipedia.org/wiki/Cryptographically-secure_pseudorandom_number_generator), or by deriving the nonce deterministically using [something like HMAC](https://datatracker.ietf.org/doc/html/rfc6979#section-3). However, there’s been a shift to Ed25519 because it prevents this issue from happening as well as being better in other respects. Furthermore, there’s also the concern mentioned in the [Key Exchange/Hybrid Encryption](#key-exchangehybrid-encryption) Avoid section that the NIST curves use [unexplained seeds](https://datatracker.ietf.org/doc/html/rfc8031#section-4), which is [not a good look](https://safecurves.cr.yp.to/rigid.html) considering that [Dual_EC_DRBG](https://en.wikipedia.org/wiki/Dual_EC_DRBG) was a NIST standard despite containing an [NSA backdoor](https://en.wikipedia.org/wiki/Dual_EC_DRBG#Weakness:_a_potential_backdoor).

5. [Post-quantum algorithms](https://csrc.nist.gov/projects/post-quantum-cryptography): these are still being researched, aren’t implemented in mainstream libraries, are much slower, and typically have very large key sizes. However, it will eventually make sense to switch to one in the future.

#### Notes:
1. Please read points 1, 2, 9, and 10 of the [Key Exchange/Hybrid Encryption](#key-exchangehybrid-encryption) Notes section because all these points about key pairs/private keys apply for signature algorithms as well.

2. Use authenticated hybrid encryption (an authenticated key exchange with authenticated encryption) instead of encryption with signatures: this is easier to get right and more efficient.

3. Use Sign-then-Encrypt **if you must use signatures with encryption** to provide sender authentication: Encrypt-then-Sign can allow an attacker to strip off the original signature and replace it with their own. For symmetric encryption, Sign-then-Encrypt-then-MAC, which involves signing the message, appending the signature to the message, and using either Encrypt-then-MAC or an AEAD, prevents this problem. Similarly, if you’re forced to use asymmetric encryption, then you can still use Sign-then-Encrypt but should include the [recipient’s name or the sender and recipient's names in the message](https://theworld.com/~dtd/sign_encrypt/sign_encrypt7.html) because the recipient needs proof that the same person signed and encrypted the message. Once the signature and encryption layers are bound together, an attacker can't remove and replace the outer layer because the reference in the inner layer will reveal the tampering. Alternatively, you can Encrypt-then-Sign-then-Encrypt or Sign-then-Encrypt-then-Sign, which are both slower.

4. **Don’t** use the same key pair for signatures (e.g. Ed25519) and key exchange (e.g. X25519): it’s [recommended](https://github.com/jedisct1/libsodium/issues/632#issuecomment-345272065) to **never use the same key for more than one thing** in cryptography. **The security of using the same key pair for these two algorithms has not been (sufficiently) studied**, signing key pairs and encryption key pairs often have different life cycles, and using different key pairs limits the damage done if one key pair is compromised. Since the keys are so small, using different key pairs produces barely any overhead as well. The only time you should really convert an Ed25519 key pair to an X25519 key pair is if you’re [heavily resource constrained](https://monocypher.org/manual/advanced/from_eddsa) or when you’re forced to use Ed25519 keys (e.g. SSH public keys off GitHub could be used for hybrid encryption).

5. Prehash large messages: signing a message normally requires loading the entire message into memory, but this can be problematic for very large (e.g. 1+ GiB) messages. To solve this problem, you can use [Ed25519ph](https://doc.libsodium.org/public-key_cryptography/public-key_signatures#multi-part-messages) or Ed448ph (which probably isn't available) to perform the prehashing for you with some additional domain separation, or you can prehash the message yourself using a strong, modern hash function, like BLAKE2b or SHA3, with a 512-bit output length and sign the hash instead of the message. However, note that not prehashing means that Ed25519 is [resistant to collisions in the hash function](https://ed25519.cr.yp.to/eddsa-20150704.pdf). Therefore, when possible, ordinary signing should arguably be preferred for additional protection, although this isn't realistically a problem if you use a secure hash function.

6. Be aware of [fault attacks](https://eprint.iacr.org/2017/1014.pdf) against deterministic signatures: techniques like causing [voltage glitches](https://cybermashup.files.wordpress.com/2017/10/practical-fault-attack-against-eddsa_fdtc-2017.pdf) on a chip (e.g. on an Arduino) can be used to recover either the entire secret key or part of the secret key, depending on the signature algorithm, and create valid signatures with algorithms like Ed25519, Ed448, and deterministic ECDSA. However, this is primarily a concern on embedded devices and requires [physical or remote access](https://eprint.iacr.org/2017/1014.pdf) to a device. Four [countermeasures](https://crypto.stackexchange.com/questions/50228/can-deterministic-ecdsa-be-protected-against-fault-attacks?rq=1) include signing the same data twice and comparing the outputs, which is obviously slower than signing once, verifying the signature after signing, which is [slower](https://eprint.iacr.org/2017/1014.pdf) than signing twice for small messages but [faster](https://eprint.iacr.org/2017/1014.pdf) for large messages, [calculating a checksum over input values](https://eprint.iacr.org/2017/1014.pdf) before and after signature generation, or using a cryptographic library that implements the algorithm with some random data in the calculation of the nonce, which is the technique used by [Signal](https://signal.org/docs/specifications/xeddsa/#security-considerations). However, these countermeasures are [not guaranteed to be effective](https://eprint.iacr.org/2017/985.pdf), and there can be other [side-channel attacks](https://en.wikipedia.org/wiki/Side-channel_attack) as well.

## Asymmetric Key Size
#### Use (in order):
1. 256-bit keys: the key size for X25519, which provides a ~128-bit security level. Why am I recommending this when I recommend 256-bit keys (a 256-bit security level) for symmetric encryption? Because X25519 is faster, more common, and [more accessible](https://en.wikipedia.org/wiki/Comparison_of_TLS_implementations#Supported_elliptic_curves) than X448. If quantum computers do come along, then [ECC](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography) and RSA will be broken regardless of the key size anyway, so many people feel less of a need to use a higher security level curve considering that 128-bit security is currently enough.

2. 456-bit keys: the key size for X448, which provides a 224-bit security level.

3. 3072-bit or 4096-bit keys: **if you’re forced to use RSA**, then the minimum key size should be 3072-bit, which is the key size [currently used by the NSA](https://www.keylength.com/en/6/) and recommended by ECRYPT for [near term protection](https://www.keylength.com/en/3/). The maximum should be 4096-bit because the performance is really bad after that. However, **seriously don’t use RSA!**

#### Avoid (not in order because they’re all bad):
1. 1024-bit keys: these are **no longer secure**.

2. 2048-bit keys: these only provide a 112-bit security level, which is below the standard 128-bit security level. Therefore, whilst commonly used and still safe as a **minimum** RSA key size, it makes sense to use 3072-bit keys instead.

3. 8192-bit keys: these are slow to generate and excessive to store.

4. Post-quantum algorithm key sizes: these algorithms are still being researched, and the key sizes are very large compared to those for [ECDH](https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman).

## Concluding Remarks
I believe there are three main areas of improvement when it comes to individuals with experience in cryptography helping developers:

1. Cryptographic libraries **should** be better: most don’t make it easy to use cryptography safely (e.g. they support insecure algorithms, require nonces, etc) and have [horrible documentation](https://www.openssl.org/docs/). This shouldn’t be the case, and there really should be greater uproar about this. Things need to be secure by default (e.g. insecure algorithms should never be implemented or get removed), and the documentation needs to be readable, as in concise, helpful to people of all skill levels, presented on a modern looking website rather than using [basic HTML](https://nacl.cr.yp.to/index.html) or [a bunch of files on GitHub](https://github.com/google/tink/tree/master/docs), and easy to navigate (e.g. supporting search functionality like [GitBook](https://doc.libsodium.org/) does).

2. People **should** stop saying 'don't roll your own crypto': **repeating this phrase doesn't help anyone**. Instead, educate developers about how to do things properly, whether that be by answering questions on [Cryptography Stack Exchange](https://crypto.stackexchange.com/) in an understandable manner, writing a [blog](https://soatok.blog/), or replying to emails from people asking for help. It's not a crime to implement Encrypt-then-MAC, and even when someone writes a custom cipher, **you should explain why that's not a good idea** (e.g. 'professional cryptographers still design insecure algorithms').

3. There **should** be more peer review: it's often difficult to receive peer review, impossible to fund a bug bounty program with cash rewards, and extremely unlikely for projects to get funding for a code audit. Whilst developers who fail to do any reading related to cryptography obviously deserve criticism, [even experienced professionals make mistakes](https://github.com/agl/ed25519/issues/27). Simple peer review (e.g. using the search on GitHub for things like 'HMAC' and 'ECB') helps catch things that are easy to spot, and more thorough peer review helps catch things that even someone experienced [might have missed](https://github.com/str4d/rage/issues/195). If something seems dodgy, then you should investigate if possible.
